<?php

/**
 * php-dna.
 *
 * Utility functions.
 *
 * @author          Devmanateam <devmanateam@outlook.com>
 * @copyright       Copyright (c) 2020-2023, Devmanateam
 * @license         MIT
 *
 * @link            http://github.com/familytree365/php-dna
 */

namespace Dna\Snps;

/**
 * The Singleton class defines the `GetInstance` method that serves as an
 * alternative to constructor and lets clients access the same instance of this
 * class over and over.
 */
class Utils
{
}

use ZipArchive;

// import datetime; // PHP has built-in date functions
// import gzip; // PHP has built-in gzip functions
// import io; // PHP has built-in I/O functions
// import logging; // You can use Monolog or another logging library in PHP
// from multiprocessing import Pool; // You can use parallel or pthreads for multi-processing in PHP
// import os; // PHP has built-in OS functions
// import re; // PHP has built-in RegExp functions
// import shutil; // PHP has built-in filesystem functions
// import tempfile; // PHP has built-in temporary file functions
// import zipfile; // PHP has built-in ZipArchive class available

// from atomicwrites import atomic_write; // You can use a library or implement atomic writes in PHP
// import pandas as pd; // There is no direct PHP alternative to pandas; consider using array functions or a data manipulation library
// import snps; // If this is a custom module, you can rewrite it in PHP and load it here

// logger = logging.getLogger(__name__); // Replace this with your preferred logging solution in PHP

class Parallelizer {
    private bool $_parallelize;
    private int $_processes;

    public function __construct(bool $parallelize = false, int $processes = null) {
        $this->_parallelize = $parallelize;
        $this->_processes = $processes ?? os_cpu_count();
    }

    public function __invoke(callable $f, array $tasks): array {
        if ($this->_parallelize) {
            // Implement parallel (multi-process) execution using pthreads, parallel or another multi-processing library
            // For example, using the parallel extension:
            // $runtime = new \parallel\Runtime();
            // $promises = [];
            // foreach ($tasks as $task) {
            //     $promises[] = $runtime->run($f, [$task]);
            // }
            // return array_map(fn($promise) => $promise->value(), $promises);
        } else {
            return array_map($f, $tasks);
        }
    }
}

function os_cpu_count(): int {
    // Use this function if you need to get the number of CPU cores in PHP
    // You might need to adjust this code based on your environment
    if (substr(php_uname('s'), 0, 7) == 'Windows') {
        return (int) shell_exec('echo %NUMBER_OF_PROCESSORS%');
    } else {
        return (int) shell_exec('nproc');
    }
}

class Singleton {
    private static array $instances = [];

    public static function getInstance(): self {
        $cls = static::class;
        if (!isset(self::$instances[$cls])) {
            self::$instances[$cls] = new static();
        }
        return self::$instances[$cls];
    }

    protected function __construct() {}
    private function __clone() {}
    private function __wakeup() {}
}

function create_dir(string $path): bool {
    if (!file_exists($path)) {
        // Create directory if it doesn't exist
        if (!mkdir($path, 0777, true)) {
            return false;
        }
    }
    return true;
}

/**
 * Save a DataFrame as a CSV file.
 *
 * @param DataFrame $df         The DataFrame to save.
 * @param string    $path       The path to the directory where the file should be saved.
 * @param string    $filename   The name of the file to save.
 * @param string    $comment    Optional comment to include at the beginning of the file.
 * @param bool      $prepend_info   Flag indicating whether to prepend version and timestamp information.
 * @param bool      $atomic     Flag indicating whether to perform an atomic write operation.
 * @param array     $kwargs     Additional keyword arguments.
 *
 * @return string   The path to the saved file, or an empty string if there was no data to save.
 */
function save_df_as_csv($df, $path, $filename, $comment = "", $prepend_info = true, $atomic = true, array $kwargs = [])
{
    $buffer = false;
    if ($filename instanceof SplFileObject) {
        $buffer = true;
    }

    if ($df instanceof DataFrame && count($df) > 0) {
        if (!$buffer && !create_dir($path)) {
            return "";
        }

        if ($buffer) {
            $destination = $filename;
        } else {
            $destination = join_paths($path, $filename);
            logger_info("Saving " . relative_path($destination));
        }

        if ($prepend_info) {
            $s = sprintf(
                "# Generated by snps v%s, https://pypi.org/project/snps/" . PHP_EOL . 
                "# Generated at %s UTC" . PHP_EOL,
                SNPS_VERSION,
                gmdate("Y-m-d H:i:s")
            );
        } else {
            $s = "";
        }

        $s .= $comment;

        if (!array_key_exists("na_rep", $kwargs)) {
            $kwargs["na_rep"] = "--";
        }

        if ($buffer) {
            if (!$destination instanceof TextIO) {
                $s = utf8_encode($s);
            }
            $destination->fwrite($s);
            to_csv($df, $destination, $kwargs);
            $destination->rewind();
        } elseif ($atomic) {
            $tmp_path = tempnam($path, 'csvtmp');
            $fd = fopen($tmp_path, 'w');

            fwrite($fd, $s);

            to_csv($df, $tmp_path, $kwargs);

            fclose($fd);

            rename($tmp_path, $destination);
        } else {
            $fd = fopen($destination, 'w');
            fwrite($fd, $s);
            to_csv($df, $destination, $kwargs);
            fclose($fd);
        }

        return $destination;
    } else {
        logger_warning("no data to save...");
        return "";
    }
}

/**
 * Cleans the input string by replacing non-word characters and leading digits with underscores.
 *
 * @param string $s The input string to clean.
 * @return string The cleaned string.
 */
function clean_str(string $s): string {
    return preg_replace('/\W|^\d/', '_', $s);
}

/**
 * Creates a ZIP archive containing a single file.
 *
 * @param string $src The path of the source file to be added to the archive.
 * @param string $dest The path where the ZIP archive will be created.
 * @param string $arcname The name of the file inside the ZIP archive.
 * @return string The path of the created ZIP archive.
 */
function zip_file(string $src, string $dest, string $arcname): string {
    $zip = new ZipArchive();
    if ($zip->open($dest, ZipArchive::CREATE) === true) {
        $zip->addFile($src, $arcname);
        $zip->close();
    }
    return $dest;
}

/**
 * Compresses a file using gzip compression algorithm.
 *
 * @param string $src The path of the source file to be compressed.
 * @param string $dest The path where the compressed file will be created.
 * @return string The path of the created compressed file.
 */
function gzip_file(string $src, string $dest): string {
    $buffer_size = 4096;
    $src_file = fopen($src, 'rb');
    $dest_file = gzopen($dest, 'wb9');

    while (!feof($src_file)) {
        $buffer = fread($src_file, $buffer_size);
        gzwrite($dest_file, $buffer);
    }

    fclose($src_file);
    gzclose($dest_file);

    return $dest;
}

?>
